### 浮动, 三列布局

### rem和其他单位的区别(em, px)


### flex布局和传统布局
传统布局： table, float

### 双飞翼布局
1. 双飞翼布局怎么保证三列高度一致
2. 双飞翼布局具体怎么实现
3. 使用flex实现双飞翼布局，三列等高


### 原型链(prototype, proto)

### 拷贝对象，深拷贝和浅拷贝
1. 浅复制 (Shallow Clone)
```
	ES5原生实现
	function shallowCopy(target) {
		var obj = {}
		for (let key in target) {
			obj[key] = target[key]
		}
		return obj
	}

	ES6: Object.assign() //assign分配
	1. 一个接受者若干个供应者，返回接受者
	2. 上述函数使用的是赋值运算符, 它无法将访问器属性复制到接受者上, 而Object.assign可以
	3. 接受者按提供者按参数顺序接收他们的属性，因此相同的属性后者会覆盖前者
	var receiver = {}
	Object.assign(receiver,
		{
			type: 'js',
			name: 'file.js'
		},
		{
			type: 'css'
		}
	)
	console.log(receiver) // {type: "css", name: "file.js"}
	4. 由于Object.assign()使用赋值运算符，供应者的访问器属性会被转换为接收者的数据属性
	var receiver = {},
	supplier = {
		get name() {
			return 'file.js'
		}
	}
	Object.assign(receiver, supplier)
	console.log(receiver) // {name: 'file.js'}
	var descriptor = Object.getOwnPropertyDescriptor(receiver, 'name')
	console.log(descriptor.value) // 'file.js'
	console.log(descriptor.get) // undefiend 

	注： 数据属性有： configurable, enumerable, writable, value 访问器属性有： configurable, enumerable, get, set
```
2. 深拷贝 (Deep Clone)
```
	1. var newObj = JSON.parse( JSON.stringify(somobj) ) 
	// function不起效果哦

	2. 递归实现(深度优先)
	function deepClone(target) {
		var obj = null
		var type = Object.prototype.toString.call(target).split(' ')[1].slice(0, -1)
		if (type === 'Array') {
			obj = []
		} else if (type === 'Object') {
			obj = {}
		} else {
			// 尽管还有其他的引用类型如function, 主要用作存储的还是Array和Object，因此其他的可以不考虑
			return target
		}
		if (type === 'Array') {
			for (let i = 0, len = target.length; i < len; i++) {
				obj[i] = deepClone(target[i])
			}
		} else {
			for (let key in target) {
				obj[key] = deepClone(target[key])
			}
		}
		return obj
	}
	3. 广度优先
	4.

```

### 遍历DOM

### vue bus总线

### vuex触发过程

### Promise

### 事件委托

### 用原生JS处理事件绑定？比如一个列表，怎么监听每个li的事件?如果新添一些li怎么办

### 怎么判断数据类型
JS分为基本数据类型和引用类型
前者有六种 number, string, boolean, null, undefined, Symbol
一般使用`typeof`, null比较特别返回object, Symbol返回function

引用类型可以理解为对象
使用`Object.prototype.toString.call`

### undefined和null的区别
undefined一般表示未定义
null表示空
undefined == null 并且它们可以 如 0 == undefined 结果为false 

### 怎么判断数组
1. ES6 Array.isArray()
2. ES5 Object.prototype.toString.call(arr) => '[object Array]'

### 作用域链
JS只有全局作用域和函数作用域，没有块级作用域
作用域链由内到外，直到全局

### JS闭包
一个函数与定义它的执行环境(execution context)的组合
红皮书中定义： 闭包就是有权访问另外一个函数作用域中的变量的函数，创建闭包最简单的方式就是在一个函数内部创建另外一个函数，不过内部的函数必须引用外部函数的变量
```
for (var i = 0;  i < 5; i++) {
	setTimeout(() => {
		console.log(i)
	}, 1000 * i)
}
每秒输出一个5
for (var i = 0;  i < 5; i++) {
	(function(i) {
		setTimeout(() => {
			console.log(i)
		}, 1000 * i)
	})(i)
	// 相当于
	/**(function(i) { <= 就是这个i
	***		var fn = () => console.log(i) // 内部函数引用的外部函数的参数i
	***		setTimeout(fn, 1000 * i)
	**/})(i)
}
```

### 普通函数和构造函数的区别
JS中对普通函数和构造函数在语法上没有任何区别，构造函数靠首字母大写来区分
唯一的区别就是在调用上，构造函数使用new
构造函数在调用时候若没有用new 实际上也就是调用普通的函数, 内部的this指向全局（严格模式是undefined）
使用new的时候this指向被创建的实例对象

> JS为函数提供了连个内部方法： `[[Call]]`和`[[Construct]]`.当函数作为一般函数调用时即未使用new，则`[[Call]]`被调用
使用new则`[[Construct]]`方法被调用，负责创建一个this指向的新对象

### 箭头函数和普通函数的区别
1. 箭头函数没有`[[Construct]]`方法，因此它无法作为构造函数
2. 箭头函数的this在函数定义时已经确定，就是包裹它的外层非箭头函数的this，没有的则指向全局(Window or Global)
3. IIFE `(() => {})()`

### 原型继承，FUNA, FUNB, 让B继承A, 用原型链怎么B继承A的属性
```
function FunA() {} // 创建构造函数FunA
var a = new FunA() // 实例化一个对象
a instanceof FunA // true 判断a是FunA的实例对象吗
FunA.prototype === a.__proto__ === Object.getPrototypeOf(a) // FunA的原型对象
FunA.prototype.constructor === FunA // 构造函数


function FunB() {
	FunA.call(this)
}
FunB.prototype = FunA.prototype
FunB.prototype.constructor = FunB // 将FunB的constructor重新指向FunB，不然等于FunA 
```

### 常用的排序算法， 快排， 冒泡， 选择排序， 各自的时间复杂度

### 跨域了解

### 前端性能优化

### position定位

### position和float的区别

### 同一对象节点上绑定多个事件，执行的循序

### 事件的冒泡和捕获

### 什么时间不支持冒泡，捕获


